{"version":3,"file":"report_view.min.js","sources":["../src/report_view.js"],"sourcesContent":["import {exception as displayException} from 'core/notification';\nimport Templates from 'core/templates';\nimport $ from 'jquery';\n\n// Our plugin focusses on the Articulate and ispring editor of SCORM\n// These editors (and others) prepend their questions with a grouping identifier like SceneX or SlideX.\n// This function is grouping the questions by using these identifiers.\n// The grouping of this data is done in js instead of the php part of the plugin, to allow for dynamic editor switches\n// in the future.\nconst group_questions = (scormdata) => {\n    let scormchartdata = {};\n    // Iterate over all sco objects of the SCROM packet.\n    for (let scoid in scormdata) {\n        // Initalize a section for this sco to store data in inside the scormchartdata array.\n        scormchartdata[scoid] = {};\n        let scodata = scormdata[scoid]?.questions || {}; // @codingStandardsIgnoreLine ? syntax is not implemented in cs\n        let scotitle = scormdata[scoid].title;\n        let groups = {};\n\n        // Loop over all Questions in this sco, try to identify their groupname and insert them into that groups data section.\n        // The question object also holds an id field that is equal to its name.\n        Object.values(scodata).forEach((questiondata) => {\n            let id = questiondata.id;\n            try {\n                let groupname = id.split('_')[0];\n                if (!(groupname in groups)) {\n                    groups[groupname] = {'data': [], 'id': groupname};\n                }\n                groups[groupname].data.push(questiondata);\n            } catch (e) {\n                // If a question names do not follow the above convention we catch them in a \"default\" group.\n                let groupname = 'default';\n                if (!(groupname in groups)) {\n                    groups[groupname] = {'data': [], 'id': 'default'};\n                }\n                groups[groupname].data.push(questiondata);\n            }\n        });\n        // Shows wrong ident, even tough ident is correct. possibly because of the nested lambdas.\n        // @codingStandardsIgnoreStart\n\n        // Now we build some statistics for those groups.\n        // We find the average perfomance as well as worst and best performing questions.\n        // Best and worst performing questions are currently not used for design choices and therefore not returned.\n        for (let key in groups) {\n            let best = 0;\n            let worst = 1;\n            let sum = 0;\n            let answersum = 0;\n            for (let question of groups[key].data) {\n                let percentage = question.correct_answers / question.total_answers;\n                if (percentage > best) {\n                    best = percentage;\n                }\n                if (percentage < worst) {\n                    worst = percentage;\n                }\n                answersum += question.total_answers;\n                sum += percentage;\n            }\n            let average = sum / groups[key].data.length;\n            groups[key].statistics = {\n                answers: answersum,\n                average: average\n            };\n        }\n        // Finally we push the gathered data into the scormchartdata object.\n        scormchartdata[scoid].groups = groups;\n        scormchartdata[scoid].title = scotitle;\n    }\n    // @codingStandardsIgnoreEnd\n    return scormchartdata;\n};\n\n// Renders a table that displays answers given by students individually.\nconst add_single_question_unscored_default = (questiondata, appendidentifier, editor) => {\n    let questiontext = get_title_from_questiondata(questiondata, editor);\n    let context = {\n        title: questiontext,\n        id_prefix: `unscored_table_switch_${questiondata.id}`,\n        answers: questiondata?.total_answers || 0, // @codingStandardsIgnoreLine ? syntax is not implemented in cs\n        identlevel: 1\n    };\n    Templates.renderForPromise('scormreport_question/collapsible_topic', context).then(({html, js}) => {\n        Templates.appendNodeContents(appendidentifier, html, js);\n        let context = {\n            'lines': questiondata?.learner_responses || [], // @codingStandardsIgnoreLine ? syntax is not implemented in cs\n            'id': questiondata.id,\n        };\n        Templates.renderForPromise('scormreport_question/unscoreddefaulttable', context).then(({html}) => {\n            // Create new table of all resposes for some reason appendNodeContents does not work here.\n            $(`#unscored_table_switch_${questiondata.id}_hiddencontent`).html(html);\n            return true;\n        }).catch(ex => displayException(ex));\n        return true;\n    }).catch(ex => displayException(ex));\n};\n\n// Renders a bar diagramm to show the distribution of numerical answers to a non-scored question.\nconst add_single_question_plotly_unscored_numeric = (questiondata, appendidentifier, editor) => {\n    let questiontext = get_title_from_questiondata(questiondata, editor);\n    let countscores = {};\n    for (let scorearray of questiondata.learner_responses) {\n        for (let score of scorearray) {\n            score = parseFloat(score);\n            if (!(score in countscores)) {\n                countscores[score] = 0;\n            }\n            countscores[score] = countscores[score] + 1;\n        }\n    }\n    let scorelevels = Object.keys(countscores);\n    let scoremax = Math.max(...scorelevels);\n    let scoremin = Math.min(...scorelevels);\n    let x = [];\n    let y = [];\n    for (let i = scoremin; i <= scoremax; i++) {\n        x.push(i);\n        y.push(i in scorelevels ? countscores[i] : 0);\n    }\n    let data = [{\n        x: x,\n        y: y,\n        type: 'bar'\n    }];\n    // @codingStandardsIgnoreLine ? syntax is not implemented in cs\n    let context = {'id': questiondata.id, title: questiontext, answers: questiondata?.total_answers || 0};\n    Templates.renderForPromise('scormreport_question/plotlysection', context).then(({html, js}) => { // Ceate new plotly wrapper.\n        Templates.appendNodeContents(appendidentifier, html, js); // Append it to the current toggleable scene.\n        window.Plotly.newPlot('scormreport_question_section_' + questiondata.id, data); // Add plotly graph.\n        return true;\n    }).catch(ex => displayException(ex));\n};\n\n// Renders a plotly violin plot for a scored question to represent the distribution of Student scores.\n// Students are scored on a scale from 0 to 100 points to represent the corectness of their answer.\nconst add_single_question_plotly_scored_violin = (questiondata, appendidentifier, editor) => {\n    let questiontext = get_title_from_questiondata(questiondata, editor);\n    let singletrace = {\n        y0: \" \", // This is the label for an individual violin plot. Since we only display one per question we dont need a title.\n        x: questiondata.percentages,\n\n        span: [0, 1], // Manually crops anything above 100% and below 0%.\n        spanmode: \"manual\", // Required for above definition to take effect.\n        meanline: {\n            \"visible\": true\n        },\n        points: 'all',\n        pointpos: 0,\n        box: {\n            'visible': true\n        },\n        jitter: 0,\n        scalemode: \"count\",\n        type: \"violin\",\n        orientation: \"h\" // Makes it horizontal\n    };\n    let layout = {\n        yaxis: {\n            zeroline: false,\n        },\n        xaxis: {\n            range: [0, 1],\n            tickformat: ',.0%' // Telling plotly to format the x-axis as percentage.\n        },\n        violinmode: \"overlay\",\n    };\n    // @codingStandardsIgnoreLine ? syntax is not implemented in cs\n    let context = {'id': questiondata.id, title: questiontext, answers: questiondata?.total_answers || 0};\n    Templates.renderForPromise('scormreport_question/plotlysection', context).then(({html, js}) => { // Ceate new plotly wrapper.\n        Templates.appendNodeContents(appendidentifier, html, js); // Append it to the current toggleable scene.\n        window.Plotly.newPlot('scormreport_question_section_' + questiondata.id, [singletrace], layout); // Add plotly graph.\n        return true;\n    }).catch(ex => displayException(ex));\n};\n\n// Renders a circle for a boolean scored question that was either 100% correct or 100% false for all students.\n// The circle represents the amount of students that got it right vs the total amount.\nconst add_single_question_boolean = (questiondata, appendidentifier, editor) => {\n    let questiontext = get_title_from_questiondata(questiondata, editor);\n\n    let correct = questiondata.correct_answers;\n    let total = questiondata.total_answers;\n    let percentage = correct * 100 / total;\n    let displaypercentage = Math.max(Math.min(100, Math.round(percentage)), 0);\n    let context = {\n        'id': questiondata.id,\n        'title': questiontext,\n        'answers': questiondata.total_answers,\n        'percentage': displaypercentage,\n        'correct': correct,\n        'total': total\n    };\n    Templates.renderForPromise('scormreport_question/scoredbinarysection', context).then(\n        ({html, js}) => {\n            Templates.appendNodeContents(appendidentifier, html, js);\n            return true;\n    }).catch(ex => displayException(ex));\n};\n\n// This function gets passed a question and the idprefix of a collapsible topic where that questions data should be visualized.\nconst add_question = (questiondata, idprefix, editor) => {\n    let onlyboolvals = false;\n    if (questiondata.displaytype === \"manual_scored\" && questiondata.percentages.length > 0) {\n        onlyboolvals = true;\n        for (let percentage of questiondata.percentages) {\n            if (percentage !== 0 && percentage !== 1) {\n                onlyboolvals = false;\n                break;\n            }\n        }\n    }\n    // The appendidentifier is the jquery selector used to append the questions visualization to.\n    // In our case we want to append the visualization of the toggleable section of the questions group.\n    let appendidentifier = `#${idprefix}_hiddencontent`;\n    // We differentiate between four types of questions.\n    // Questions that are scored can either be:.\n    if (questiondata.displaytype === \"result_scored\" || onlyboolvals) {\n        // ... result based. This means the question is either answered right or wrong.\n        // As such visualization is based on the percentage of correct students.\n        add_single_question_boolean(questiondata, appendidentifier, editor);\n    } else if (questiondata.displaytype === \"manual_scored\") {\n        // ... manually scored. This means that students answers lie on a spectrum that determines their \"correctness\"\n        // To visualize this, students answers are aggreagted in a violin plot.\n        add_single_question_plotly_scored_violin(questiondata, appendidentifier, editor);\n    } else if (questiondata.displaytype === \"numeric_unscored\") {\n        // Or Questions can be unscored.\n        // If the Question has only numeric answers we visualize their distribution in a Bar chart instead of a violin chart\n        // ...this is possible because these answers usually don't vary a lot and are all integers unlike percentages.\n        add_single_question_plotly_unscored_numeric(questiondata, appendidentifier, editor);\n    } else if (questiondata.displaytype === \"default_unscored\") {\n        // If the question is not scored and not numeric it's most likely a free-text answer.\n        // In that case we just display all the students answers.\n        add_single_question_unscored_default(questiondata, appendidentifier, editor);\n    }\n};\n\n// @codingStandardsIgnoreStart\n/* eslint-disable */\n// coding standards recognize regex as mathematical operands.\n// Also expects whitespace before/after optional chaining operand ? which is semantically incorrect.\n\n// This function trys to predict what editor was used to create the SCROM packet.\nconst predict_editor = (scormdata) => {\n    for (let sco of Object.values(scormdata)) {\n        for (let question of Object.values(sco.questions)) {\n            if (question.description !== \"\") {\n                // The articulate editor typically puts the questions text in the description.\n                return \"articulate\";\n            } else if (question.id.match(/Slide\\d+_Q_[^_]*_(?:\\d*_)?_?((?<!__).*)/)?.length || 0 > 1) {\n                // The ispring editor puts the Questionname in the id of the question and follows a very specific format.\n                return \"ispring\";\n            }\n        }\n    }\n    return \"default\";\n};\n\n// Callback map to get a title for a set editor.\n// The x?.y || z syntax returns x.y if it exists and isn't falsy otherwise it returns z\n// The ?. can be chained in that case none of them may be falsy to return x.y\nconst _editorcallbacks = {\n    'articulate': (questiondata) => questiondata.description !== \"\" ? questiondata.description.trim() : questiondata.id,\n    'ispring': ((questiondata) => questiondata.id.match(/Slide\\d+_Q_[^_]*_(?:\\d*_)?_?((?:(?<!____).)*)/)?.[1]?.replaceAll('_', ' ')\n        || get_title_for_editor['default'](questiondata)),\n    'default': (questiondata) => questiondata.id\n};\n/* eslint-enable */\n// @codingStandardsIgnoreEnd\nconst get_title_from_questiondata = (questiondata, editor = 'default') => {\n    // @codingStandardsIgnoreLine ? syntax is not implemented in cs\n    return _editorcallbacks?.[editor](questiondata) || _editorcallbacks['default'](questiondata);\n};\n\nconst init_editor_choser = (scormdata, predicted_editor) => {\n    // Change the dropdown to have the predicted editor selected.\n    $('#scormreport_question_choose_editor').val(predicted_editor);\n    // Define onchange callback for the editor selection dropdown.\n    $('#scormreport_question_choose_editor').change(() => {\n        let editor = $('#scormreport_question_choose_editor').val().toLowerCase();\n        for (let sco of Object.values(scormdata)) {\n            for (let question of Object.values(sco.questions)) {\n                // Set new title for questionsections (plotly and circle).\n                $(`#scormreport_question_sectionwrapper_${question.id} > div > h2`)\n                    .text(get_title_from_questiondata(question, editor));\n                // @codingStandardsIgnoreStart Coding standards doesn't like = without whitespaces.\n                // Also change the title for tables. (unscored non-numeric questions)\n                $(`label[for=unscored_table_switch_${question.id}_switch]`).text(get_title_from_questiondata(question, editor));\n                // @codingStandardsIgnoreEnd\n            }\n        }\n        return 0;\n    });\n};\n\nexport const init = (questiondata) => {\n\n    // Group the questiondata into sections.\n    // This is done in js over php to allow for a future setting that specifies the used editor.\n    let sections = group_questions(questiondata);\n\n    // Predict what editor we are using.\n    let editor = predict_editor(questiondata);\n\n    // The below if / else sections are very similar.\n    // The first is used when there is only one SCO in the SCORM. This is the case most of the time.\n    // The else part basically wraps the one-SCO version into one additional collapsible section per sco.\n    if (Object.keys(sections).length === 1) {\n        sections = sections[Object.keys(sections)[0]];\n        // Fetch sections from the sectionobject.\n        for (let section in sections.groups) {\n            // Append a collapsible section with statistical information about the students' performance in this section.\n            let sectiondata = sections.groups[section];\n            let idprefix = `scormreport_question_${section}`;\n            let context = {\n                'id_prefix': idprefix,\n                'title': section,\n                'answers': sectiondata.statistics.answers,\n                'average': (sectiondata.statistics.average * 100).toFixed(2),\n            };\n            Templates.renderForPromise('scormreport_question/collapsible_topic', context)\n                .then(({html, js}) => {\n                    Templates.appendNodeContents('#scormreport_question_container', html, js);\n                    for (let questiondata of sectiondata.data) {\n                        // Add the questiongraphs/visaulizers to the collapsible section.\n                        add_question(questiondata, idprefix, editor);\n                    }\n                    return true;\n                })\n                .catch(ex => displayException(ex));\n\n        }\n    } else {\n        for (let scoid of Object.keys(sections)) {\n            let scodata = sections[scoid];\n            let context = {\n                'id_prefix': `scormreport_question_scosection${scoid}`,\n                'title': `${scodata.title}`,\n            };\n            Templates.renderForPromise('scormreport_question/collapsible_topic', context)\n                .then(({html, js}) => {\n                    Templates.appendNodeContents('#scormreport_question_container', html, js);\n                    for (let section in scodata.groups) {\n                        let sectiondata = scodata.groups[section];\n                        let idprefix = `scormreport_question_${section}`;\n                        let context = {\n                            'id_prefix': idprefix,\n                            'title': section,\n                            'answers': sectiondata.statistics.answers,\n                            'average': (sectiondata.statistics.average * 100).toFixed(2),\n                        };\n                        Templates.renderForPromise('scormreport_question/collapsible_topic', context)\n                            .then(({html, js}) => {\n                                Templates.appendNodeContents(`#scormreport_question_scosection${scoid}_hiddencontent`, html, js);\n                                for (let questiondata of sectiondata.data) {\n                                    add_question(questiondata, idprefix, editor);\n                                }\n                                return true;\n                            }).catch(ex => displayException(ex));\n\n                    }\n                }).catch(ex => displayException(ex));\n        }\n    }\n    init_editor_choser(questiondata, editor);\n};"],"names":["_templates","_interopRequireDefault","_jquery","add_question","questiondata","idprefix","editor","onlyboolvals","displaytype","percentages","length","_step4","_iterator4","s","n","done","percentage","value","err","e","f","appendidentifier","questiontext","get_title_from_questiondata","correct","correct_answers","total","total_answers","displaypercentage","Math","max","min","round","context","id","title","answers","Templates","default","renderForPromise","then","_ref5","html","js","appendNodeContents","catch","ex","displayException","add_single_question_boolean","singletrace","y0","x","span","spanmode","meanline","visible","points","pointpos","box","jitter","scalemode","type","orientation","layout","yaxis","zeroline","xaxis","range","tickformat","violinmode","_ref4","window","Plotly","newPlot","add_single_question_plotly_scored_violin","_step2","countscores","learner_responses","_iterator2","_step3","_iterator3","_createForOfIteratorHelper","score","parseFloat","scorelevels","Object","keys","scoremax","y","i","push","data","_ref3","add_single_question_plotly_unscored_numeric","id_prefix","identlevel","_ref","lines","_ref2","$","add_single_question_unscored_default","_editorcallbacks","articulate","description","trim","ispring","_questiondata$id$matc","_questiondata$id$matc2","match","replaceAll","get_title_for_editor","scormdata","predicted_editor","sections","scormchartdata","_loop","scoid","_scormdata$scoid","scodata","questions","scotitle","groups","key","values","forEach","groupname","split","_step","best","worst","sum","answersum","_iterator","question","average","statistics","group_questions","_i","_Object$values","sco","_i2","_Object$values2","_question$id$match","predict_editor","_loop2","section","sectiondata","toFixed","_ref6","_step5","_iterator5","_loop3","_Object$keys","_i5","concat","_ref7","_loop4","_ref8","_step6","_iterator6","val","change","toLowerCase","_i3","_Object$values3","_i4","_Object$values4","text"],"mappings":"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"}